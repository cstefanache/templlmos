<html>
 <head>
  <style id="osbase_general-styles">
   body {
    background-color: #f8d0e8; /* Lite Pink */
    overflow: hidden; /* Hidden Overflow */
}
  </style>
  <script id="osbase_global-objects">
   (() => {
window.os = {};


})()
  </script>
  <script id="osbase_about">
   (() => {
/**
 * Returns information about the operating system.
 * @return {string} Information about the operating system.
 */
window.os.about = function() {
    return "TempLLMOS is an experimental WebOS controlled by a Large Language Model.";
};

/**
 * Logs a message to the console.
 * @param {string} message - The message to be logged.
 */
window.os.log = function(message) {
    console.log(message);
};


})()
  </script>
  <script id="osbase_filesystem">
   (() => {
// Load the filesystem object from localStorage
let filesystem = JSON.parse(localStorage.getItem('filesystem')) || {};

// Define window.os.fs
if (!window.os) {
    window.os = {};
}
if (!window.os.fs) {
    window.os.fs = {};
}

/**
 * Save the filesystem object to localStorage
 */
window.os.fs.sync = function() {
    localStorage.setItem('filesystem', JSON.stringify(filesystem));
}

/**
 * Get file content at given path
 * @param {string} path - The path to the file
 * @returns {string|undefined} - The content of the file or undefined if not found
 */
window.os.fs.getFileContentFromPath = function(path) {
    path = path.replace(/^\/|\/$/g, '').split('/');
    let current = filesystem;
    for (let dir of path) {
        if (!current[dir]) {
            return undefined;
        }
        current = current[dir];
    }
    return typeof current === 'string' ? current : undefined;
}

/**
 * Write content to a file at given path
 * @param {string} path - The path to the file
 * @param {string} content - The content to write to the file
 */
window.os.fs.write = function(path, content) {
    path = path.replace(/^\/|\/$/g, '').split('/');
    let current = filesystem;
    for (let dir of path.slice(0, -1)) {
        if (!current[dir]) {
            current[dir] = {};
        }
        current = current[dir];
    }
    current[path[path.length - 1]] = content;
    this.sync();
}

/**
 * List entries at given path
 * @param {string} path - The path to list entries at
 * @returns {Array} - An array of entries at the path or root if path is not found
 */
window.os.fs.ls = function(path = '') {
    path = path.replace(/^\/|\/$/g, '').split('/');
    let current = filesystem;
    for (let dir of path) {
        if (!current[dir]) {
            return Object.keys(filesystem);
        }
        current = current[dir];
    }
    return Object.keys(current);
}

/**
 * Create a directory at given path
 * @param {string} path - The path to create a directory at
 */
window.os.fs.mkdir = function(path) {
    path = path.replace(/^\/|\/$/g, '').split('/');
    let current = filesystem;
    for (let dir of path) {
        if (!current[dir]) {
            current[dir] = {};
        }
        current = current[dir];
    }
    this.sync();
}

/**
 * Remove a file or directory at given path
 * @param {string} path - The path to remove at
 */
window.os.fs.rm = function(path) {
    path = path.replace(/^\/|\/$/g, '').split('/');
    let current = filesystem;
    let parent = filesystem;
    for (let dir of path.slice(0, -1)) {
        if (!current[dir]) {
            return; // Path not found
        }
        parent = current;
        current = current[dir];
    }
    delete parent[path[path.length - 1]];
    this.sync();
}

/**
 * Check if a path is a file
 * @param {string} path - The path to check
 * @returns {boolean} - True if path is a file, false otherwise
 */
window.os.fs.isFile = function(path) {
    path = path.replace(/^\/|\/$/g, '').split('/');
    let current = filesystem;
    for (let dir of path) {
        if (!current[dir]) {
            return false; // Path not found or not a file
        }
        current = current[dir];
    }
    return typeof current === 'string'; // Check if current is a string (file)
}


})()
  </script>
  <style id="desktop_content-style">
   #desktop_content {
    position: absolute;
    width: 100%;
    height: 100%;
    overflow-y: hidden;
    padding: 10px;
    display: flex;
    flex-wrap: wrap;
    flex-direction: column;
    align-content: flex-start;
}
  </style>
  <style id="desktop_styles">
   .icon {
    width: 64px;
    min-height: 64px;
    text-align: center;
    margin: 5px;
    cursor: pointer;
    position: relative;
    display: flex;
    flex-direction: column;
}

.emoji {
    display: block;
    font-size: 30px;
    display: inline-block;
    position: relative;
}

.title {
    display: block;
    font-size: 8px;
    font-family: monospace;
    color: black;
    padding: 5px;
    word-wrap: break-word;
    border: 2px solid black;
    background-color: white;
    border-radius: 5px;
}

.app-emoji {
    position: absolute;
    right: 12px;
    top: 20px;
}
  </style>
  <script id="desktop_icon">
   (() => {
// Check if window.os exists, if not create it
if (!window.os) {
    window.os = {};
}

/**
 * Create an icon element with an emoji and a tooltip.
 * @param {HTMLElement} parent - The parent element to append this icon to.
 * @param {string} emoji - The emoji to display in this icon.
 * @param {string} title - The tooltip text to display when hovering over this icon.
 * @param {function} callback - The callback to call when this icon is clicked.
 */
window.os.icon = function(parent, emoji, title, callback) {
    // Create root DOM element with class .icon
    var icon = document.createElement('div');
    icon.classList.add('icon');
    
    // Create span with class .emoji and add it to icon
    var emojiSpan = document.createElement('span');
    emojiSpan.classList.add('emoji');
    emojiSpan.textContent = emoji;
    icon.appendChild(emojiSpan);
    
    // Create span with class .title and add it to icon
    var titleSpan = document.createElement('span');
    titleSpan.classList.add('title');
    titleSpan.textContent = title;
    icon.appendChild(titleSpan);
    
    // Add click event listener to icon
    icon.addEventListener('click', callback);
    
    // Append icon to parent
    parent.appendChild(icon);
};


})()
  </script>
  <script id="desktop_desktop-app">
   (() => {
/**
 * Adds an application to the desktop content.
 * @param {string} emoji - The emoji to display in this application's icon.
 * @param {string} title - The tooltip text to display when hovering over this application's icon.
 * @param {function} callback - The callback to call when this application's icon is clicked.
 */
window.os.addApp = function(emoji, title, callback) {
    window.os.icon(document.querySelector('#desktop_content'), emoji, title, callback);
};


})()
  </script>
  <style id="output_output-styles">
   .output-wrapper {
    position: fixed;
    top: 0;
    right: 0;
    width: 40%;
    max-width: 500px;
    height: 100vh; /* viewport height */
}

.output {
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5); /* semi-transparent black */
    color: white; /* white text */
    white-space: pre-wrap; /* text wrap */
    font-size: 9px;
    padding: 10px; /* padding */
    margin: 0; /* no margins */
    overflow: auto; /* scroll if content overflows */
}
  </style>
  <script id="gui_draggable">
   (() => {
if (!window.os) {
    window.os = {};
}
if (!window.os.gui) {
    window.os.gui = {};
}

/**
 * Makes an element draggable by a given handle element.
 * @param {HTMLElement} root - The element to be made draggable.
 * @param {HTMLElement} dragHandleHTMLElement - The handle element to initiate the drag operation.
 */
window.os.gui.makeDraggable = function(root, dragHandleHTMLElement) {
    let isDragging = false;
    let offsetX = 0;
    let offsetY = 0;
    
    const handleMouseDown = (event) => {
        isDragging = true;
        offsetX = event.clientX - root.getBoundingClientRect().left;
        offsetY = event.clientY - root.getBoundingClientRect().top;
        
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
    };
    
    const handleMouseMove = (event) => {
        if (isDragging) {
            const x = event.clientX - offsetX;
            const y = event.clientY - offsetY;
            
            // Prevent the element from being dragged off the screen
            const boundingRect = document.body.getBoundingClientRect();
            const rootRect = root.getBoundingClientRect();
            if (x < boundingRect.left || y < boundingRect.top || x + rootRect.width > boundingRect.right || y + rootRect.height > boundingRect.bottom) {
                return;
            }
            
            root.style.left = `${x}px`;
            root.style.top = `${y}px`;
        }
    };
    
    const handleMouseUp = () => {
        isDragging = false;
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
    };
    
    dragHandleHTMLElement.addEventListener('mousedown', handleMouseDown);
};

/**
* Makes an element resizable by a given handle element.
* @param {HTMLElement} root - The element to be made resizable.
* @param {HTMLElement} resizeHandleHTMLElement - The handle element to initiate the resize operation.
*/
window.os.gui.makeResizable = function(root, resizeHandleHTMLElement) {
    let startWidth = root.offsetWidth;
    let startHeight = root.offsetHeight;
    let startX;
    let startY;
    
    resizeHandleHTMLElement.addEventListener('mousedown', (e) => {
        e.preventDefault();
        startX = e.clientX;
        startY = e.clientY;
        
        document.addEventListener('mousemove', resize);
        document.addEventListener('mouseup', stopResize);
    });
    
    function resize(e) {
        let width = startWidth + (e.clientX - startX);
        let height = startHeight + (e.clientY - startY);
        
        // Ensure width and height are not negative
        width = Math.max(width, 0);
        height = Math.max(height, 0);
        
        // Update width and height of root element
        root.style.width = width + 'px';
        root.style.height = height + 'px';
    }
    
    function stopResize() {
        // Update starting width and height on mouseup
        startWidth = root.offsetWidth;
        startHeight = root.offsetHeight;
        
        // Remove event listeners
        document.removeEventListener('mousemove', resize);
        document.removeEventListener('mouseup', stopResize);
    }
};

/**
* Brings the specified DOM node to the front of its siblings.
* @param {HTMLElement} rootDOMNode - The DOM node to bring to front.
*/
window.os.gui.bringToFront = function(rootDOMNode) {
    // Internal function to bring to front
    var bringToFront = function() {
        // Get all elements with same class as rootDOMNode
        var siblings = document.getElementsByClassName(rootDOMNode.className);
        // Iterate through them and set z-index to 0
        for (var i = 0; i < siblings.length; i++) {
            siblings[i].style.zIndex = 0;
        }
        // Set z-index of rootDOMNode to 1
        rootDOMNode.style.zIndex = 1;
    };
    
    // Call internal function on mousedown event of rootDOMNode
    rootDOMNode.addEventListener('mousedown', bringToFront);
    
    // Call internal function immediately to bring to front on load
    bringToFront();
};


})()
  </script>
  <script id="gui_titleBar">
   (() => {
// Assuming window.os is an existing object with gui as its property
if (!window.os) {
    window.os = {};
}
if (!window.os.gui) {
    window.os.gui = {};
}

/**
 * Creates a title bar with a title and a close button.
 * @param {HTMLElement} parentElement - The DOM element to append this title bar to.
 * @param {string} title - The title to display in the title bar.
 * @param {function} close - The callback to call when the close button is clicked.
 */
window.os.gui.titleBar = function(parentElement, title, close) {
    // Create root element
    var root = document.createElement('div');
    root.classList.add('titleBar');
    
    // Create title span
    var titleSpan = document.createElement('span');
    titleSpan.textContent = title;
    root.appendChild(titleSpan);
    
    // Create close button
    var closeButton = document.createElement('button');
    closeButton.textContent = '❌';
    closeButton.classList.add('close');
    closeButton.addEventListener('click', close); // Add click event listener to close button
    root.appendChild(closeButton);
    
    // Append root to parent element
    parentElement.appendChild(root);
};


})()
  </script>
  <script id="gui_toolbar">
   (() => {
/**
 * Create a toolbar with a button inside it.
 * @param {HTMLElement} win - The window element to add toolbar to.
 * @returns {function(string, function): void} - The addButton function.
 */
window.os.gui.createToolbar = function(win) {
    // Create a root DOM element with class .toolbar
    var toolbar = document.createElement('div');
    toolbar.className = 'toolbar';
    
    // Append the root DOM element to .toolbarPlaceholder from win HTML element
    win.querySelector('.toolbarPlaceholder').appendChild(toolbar);
    
    /**
     * Add a button to the toolbar with a specific text and callback when clicked.
     * @param {string} text - The text to display on the button.
     * @param {function} callback - The callback to call when the button is clicked.
     */
    var addButton = function(text, callback) {
        // Create a button element with text parameter
        var button = document.createElement('button');
        button.textContent = text;
        
        // Add event listener to call callback when button is clicked
        button.addEventListener('click', callback);
        
        // Append button to toolbar root element
        toolbar.appendChild(button);
    };
    
    // Return addButton function
    return addButton;
};


})()
  </script>
  <script id="gui_window">
   (() => {
/**
* Create a new window with given emoji, title, width and height.
* @param {string} emoji - The emoji to display in the window's title bar.
* @param {string} title - The title to display in the window's title bar.
* @param {number} [width=400] - The width of the window in pixels.
* @param {number} [height=300] - The height of the window in pixels.
* @return {HTMLElement} The root DOM element of the newly created window.
*/
window.os.gui.createWindow = function(emoji, title, width = 400, height = 300) {
    // Create root DOM element
    const root = document.createElement('div');
    root.className = 'window';
    root.style.width = `${width}px`;
    root.style.height = `${height}px`;
    document.body.appendChild(root);
    
    // Bring to front
    window.os.gui.bringToFront(root);
    
    // Create placeholders for title bar, toolbar, content, status
    ['titlePlaceholder', 'toolbarPlaceholder', 'contentPlaceholder', 'statusPlaceholder'].forEach(className => {
        const placeholder = document.createElement('div');
        placeholder.className = className;
        root.appendChild(placeholder);
    });
    
    // Create resize handle
    const resizeHandle = document.createElement('div');
    resizeHandle.className = 'resizeHandle';
    root.appendChild(resizeHandle);
    
    // Create title bar
    window.os.gui.titleBar(root.querySelector('.titlePlaceholder'), emoji + ' ' + title, () => document.body.removeChild(root));
    
    // Make window draggable by title bar
    window.os.gui.makeDraggable(root, root.querySelector('.titlePlaceholder'));
    
    // Make window resizable by resize handle
    window.os.gui.makeResizable(root, resizeHandle);
    
    // Position window in center of document
    root.style.position = 'absolute';
    root.style.left = `${window.innerWidth / 2 - width / 2}px`;
    root.style.top = `${window.innerHeight / 2 - height / 2}px`;
    
    return root;
};

/**
* Attach content to an existing window.
* @param {HTMLElement} windowElement - The window to attach content to.
* @param {HTMLElement} contentElement - The content to attach to the window.
*/
window.os.gui.attachToWindow = function(windowElement, contentElement) {
    // Find the .contentPlaceholder element in the windowElement
    var contentPlaceholder = windowElement.querySelector('.contentPlaceholder');
    
    // Append the contentElement to the .contentPlaceholder element
    contentPlaceholder.appendChild(contentElement);
};


})()
  </script>
  <style id="gui_gui-styles">
   /* Define styles for .titleBar */
.titleBar {
    background-color: orange;
    border-bottom: 1px solid black;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-family: monospace;
    font-size: small;
    padding: 0px 5px;
    border-bottom: 2px solid black;
    user-select: none; /* Prevent text selection */
}

/* Define styles for buttons */
.titleBar button {
    border: none;
    background: none;
    cursor: pointer;
    font-size: 6px;
    padding: 5px;
}

.window {
    position: absolute;
    display: flex;
    flex-direction: column;
    border: 2px solid black;
    border-radius: 8px;
    box-shadow: 4px 4px 0 0 rgba(0,0,0,0.5);
    overflow: hidden;
    background-color: white;
    -webkit-user-select: none; /* Safari */
    -ms-user-select: none; /* IE 10+ */
    user-select: none; /* Standard syntax */
}

.contentPlaceholder {
    padding: 5px;
    flex-grow: 1;
    overflow: auto;
}

.statusPlaceholder {
    border-top: 1px solid black;
    font-family: monospace;
    font-size: small;
}

.resizeHandle {
    position: absolute;
    width: 0px;
    height: 0px;
    bottom: 0;
    right: 0;
    cursor: se-resize;
    border-width: 0 0 10px 10px;
    border-style: solid;
    border-color: transparent transparent #ff7200 transparent;
    transform: rotate(0deg);
}

.toolbar {
    padding: 2px;
    background-color: antiquewhite;
    margin-bottom: 2px;
    border-bottom: 1px solid black;
    display: flex;
    justify-content: flex-start;
}

button {
    border: none;
    cursor: pointer;
    background-color: transparent;
}
  </style>
  <script id="registry_extension">
   (() => {
// Assuming window.os is already defined
if (!window.os) {
    window.os = {};
}

// Assuming window.os.registry is already defined
if (!window.os.registry) {
    window.os.registry = {};
}

/**
 * Register an extension with its corresponding emoji and callback.
 * @param {string} extension - The name of the extension to register.
 * @param {string} emoji - The corresponding emoji for this extension.
 * @param {function} callback - The callback to be executed when this extension is used.
 */
window.os.registerExtension = function(extension, emoji, callback) {
    window.os.registry[extension] = {emoji: emoji, callback: callback};
};


})()
  </script>
  <script id="registry_app-icon">
   (() => {
/**
 * Create an icon element for a file or directory at given path
 * @param {string} path - The path to the file or directory
 * @param {function} callback - The callback to call when the icon is clicked
 * @returns {HTMLElement} - The icon element
 */
window.os.getOSIcon = function(path, callback) {
    const isFile = window.os.fs.isFile(path);
    const rootElement = document.createElement('div');
    rootElement.classList.add('icon');
    
    const emojiElement = document.createElement('span');
    emojiElement.classList.add('emoji');
    emojiElement.textContent = isFile ? '📄' : '📁';
    rootElement.appendChild(emojiElement);
    
    const titleElement = document.createElement('div');
    titleElement.classList.add('title');
    titleElement.textContent = path.split('/').pop(); // Assuming path is a Unix-like path
    rootElement.appendChild(titleElement);
    
    const ext = path.split('.').pop(); // Assuming path has an extension
    const extData = window.os.registry[ext];
    if (extData) {
        const appEmojiElement = document.createElement('span');
        appEmojiElement.classList.add('app-emoji');
        appEmojiElement.textContent = extData.emoji;
        rootElement.appendChild(appEmojiElement);
        
        let currentCallback = path => extData.callback(path); // Closure for path
        rootElement.addEventListener('click', () => currentCallback(path));
    } else {
        let currentCallback = path => callback(path); // Closure for path
        rootElement.addEventListener('click', () => currentCallback(path));
    }
    
    return rootElement;
};


})()
  </script>
  <script id="registry_registry">
   (() => {
/**
 * Register an application on the desktop.
 * 
 * @param {string} title - The tooltip text to display when hovering over this application's icon.
 * @param {string} emoji - The emoji to display in this application's icon.
 * @param {function} callback - The callback to call when this application's icon is clicked.
 * @param {number} [width=400] - The width of the application's window in pixels.
 * @param {number} [height=400] - The height of the application's window in pixels.
 * @param {Array<string>} [extensions] - The file extensions to register for this application.
 */
window.os.registerApplication = function(title, emoji, callback, width = 400, height = 400, extensions) {
    const execute = (...params) => {
        const windowInstance = window.os.gui.createWindow(emoji, title, width, height);
        window.os.gui.attachToWindow(windowInstance, callback(windowInstance, ...params));
    };
    
    if (extensions) {
        extensions.forEach(extension => {
            // Assuming `registerExtension` is also available on `window.os` object
            // and it takes an extension, emoji and callback as parameters
            window.os.registerExtension(extension, emoji, execute);
        });
    }
    
    // Add application to desktop
    window.os.addApp(emoji, title, () => execute());
};


})()
  </script>
  <style id="apps_styles">
   .browser {
    display: flex;
    flex-wrap: wrap;
}
  </style>
  <script id="development_run">
   (() => {
/**
 * Run an application in a new window.
 * @param {function} callback - The callback to run in the new window.
 * @param {number} [width=500] - The width of the window in pixels.
 * @param {number} [height=400] - The height of the window in pixels.
 */
window.os.runApp = function(callback, width = 500, height = 400) {
    // Create a new window instance
    const appWindow = window.os.gui.createWindow('🔥', 'Development', width, height);
    
    // Attach content to the window
    const contentElement = callback(appWindow);
    window.os.gui.attachToWindow(appWindow, contentElement);
};


})()
  </script>
  <style id="games_styles">
   .gmroot {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    margin: 2px;
    padding: 4px;
    background-color: white;
}

.row {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
}

.cell {
    width: 22px;
    height: 22px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    border: 1px solid darkgray;
    border-radius: 2px;
    margin: 1px;
    font-family: monospace;
}

.cell.visited {
    background-color: white;
    border: 1px solid white;
}

.score {
    margin: 4px;
    font-family: monospace;
    font-weight: bold;
    text-align: center;
    background-color: white;
    border: 2px solid white;
    border-radius: 2px;
}
  </style>
 </head>
 <body>
  <script id="osbase_tests">
   (() => {
/**
 * Executes log with about message.
 */
function executeLogWithAbout() {
    window.os.log(window.os.about());
}


})()
  </script>
  <script id="osbase_fs-tests">
   (() => {
// Create a new directory in the root directory called `fstest`
window.os.fs.mkdir('fstest');

// Create a new file in the `fstest` directory called `test.txt` with the content `hello world`
window.os.fs.write('fstest/test.txt', 'hello world');

// List the entries in the `fstest` directory and log it to console
console.log(window.os.fs.ls('fstest'));

// Read the content of the `fstest/test.txt` file and log it to console
console.log(window.os.fs.getFileContentFromPath('fstest/test.txt'));

// Remove the `fstest` directory 
window.os.fs.rm('fstest');


})()
  </script>
  <div id="desktop_content">
  </div>
  <script id="output_output-window">
   (() => {
// Create root container div element
let outputWrapper = document.createElement('div');
outputWrapper.className = 'output-wrapper';
outputWrapper.id = 'output-wrapper';
document.body.appendChild(outputWrapper);

// Create pre element
let output = document.createElement('pre');
output.className = 'output';
output.id = 'output';
outputWrapper.appendChild(output);

// Internal function to fetch content from 'http://localhost:8080/output'
async function fetchContent() {
    try {
        let response = await fetch('http://localhost:8080/output');
        let data = await response.text();
        output.innerHTML = data;
    } catch (error) {
        console.error('Error:', error);
    }
}

// Call http://localhost:8080/ping
fetch('http://localhost:8080/ping')
    .then(response => {
        if (response.status === 200) {
            // If response is 200, set an interval to call fetchContent every 1000ms
            setInterval(fetchContent, 1000);
        } else {
            console.error('Ping failed with status', response.status);
        }
    })
    .catch(error => {
        console.error('Error:', error);
    });


})()
  </script>
  <script id="registry_hello-world">
   (() => {
/**
 * Create a root element div having an h1 child element with 'Hello World' text
 * If path is defined append a pre element containing the content of reading the file at the path
 * @param {HTMLElement} parent - The parent element to append the created elements to
 * @param {string} [path] - The path to a file to read its content from
 * @returns {HTMLElement} - The root element containing h1 and pre elements
 */
function helloWorld(parent, path) {
    // Create root div element
    const root = document.createElement('div');
    
    // Create h1 element with 'Hello World' text
    const h1 = document.createElement('h1');
    h1.textContent = 'Hello World';
    root.appendChild(h1);
    
    // If path is provided, create pre element with file content
    if (path) {
        const pre = document.createElement('pre');
        pre.textContent = window.os.fs.getFileContentFromPath(path);
        root.appendChild(pre);
    }
    
    // Append root element to parent
    parent.appendChild(root);
    
    return root;
}

// Register application with 'hello world' title, 👋 as emoji, helloWorld function and 300x200 size
window.os.registerApplication('hello world', '👋', helloWorld, 300, 200);


})()
  </script>
  <script id="apps_editor">
   (() => {
function editor(win, path) {
    // Create a div element with class 'editor'
    const editorDiv = document.createElement('div');
    editorDiv.className = 'editor';
    
    // Create a textarea element with 100% width and 400px height
    const textarea = document.createElement('textarea');
    textarea.style.width = '100%';
    textarea.style.height = '400px';
    editorDiv.appendChild(textarea);
    
    // Create toolbar on the window parameter
    const addButton = window.os.gui.createToolbar(win);
    
    // If path is not empty, read the file content and set it to the textarea
    if (path) {
        const content = window.os.fs.getFileContentFromPath(path);
        if (content) textarea.value = content;
    }
    
    // Add button on the toolbar with '💾' text save textarea content to the path if path is defined, prompt for the path otherwise
    addButton('💾', () => {
        const newPath = path || window.prompt('Enter a path');
        if (newPath) window.os.fs.write(newPath, textarea.value);
    });
    
    // Return the div element
    return editorDiv;
}

// Register application with 'Editor' title, ✍️ as emoji, editor function reference and 400x450 size for [txt,doc] extensions 
window.os.registerApplication('Editor', '✍️', editor, 400, 450, ['txt', 'doc']);


})()
  </script>
  <script id="apps_browser">
   (() => {
function browser(win, path='') {
    // Create a container dom element with class `browser`
    let container = document.createElement('div');
    container.className = 'browser';
    
    // Set browserPath to path or `''` if path is undefined or not string
    let browserPath = (typeof path === 'string') ? path : '';
    
    // Generate internal load function that takes path parameter
    let load = (path) => {
        // Set browserPath to path
        browserPath = path;
        
        // Removes all children of the container element
        while (container.firstChild) {
            container.removeChild(container.firstChild);
        }
        
        // If path is not empty, create a new `div` with class icon, inner element `.emoji` with internal span element having content '🔙'  and class `emoji` and on click call load with `path.split('/').slice(0, -1).join('/')`
        if (path !== '') {
            let backButtonDiv = document.createElement('div');
            backButtonDiv.className = 'icon';
            let backButtonSpan = document.createElement('span');
            backButtonSpan.className = 'emoji';
            backButtonSpan.innerText = '🔙';
            backButtonSpan.onclick = () => load(path.split('/').slice(0, -1).join('/'));
            backButtonDiv.appendChild(backButtonSpan);
            container.appendChild(backButtonDiv);
        }
        
        // ls all files in the path and for each item call `getOsIcon` with path+'/'+item and load function as callback
        window.os.fs.ls(path).forEach(item => {
            let iconElement = window.os.getOSIcon(path+'/'+item, () => load(path+'/'+item));
            container.appendChild(iconElement);
        });
    };
    
    // Execute load on browserPath variable
    load(browserPath);
    
    // Create toolbar
    let toolbar = window.os.gui.createToolbar(win);
    
    // Call `addButton` on the toolbar with `📁` text and prompt for a name and call mkdir on current browserPath and provided name
    toolbar('📁', () => {
        let name = prompt('Enter directory name');
        window.os.fs.mkdir(browserPath + '/' + name);
        load(browserPath);
    });
    
    // Call `addButton` on the toolbar with `📄` text and prompt for a name and call write on current browserPath and provided name and '' as content
    toolbar('📄', () => {
        let name = prompt('Enter file name');
        window.os.fs.write(browserPath + '/' + name, '');
        load(browserPath);
    });
    
    // Return dom element 
    return container;
}

window.os.registerApplication('Browser', '📂', browser, 450, 400);


})()
  </script>
  <script id="development_ide">
   (() => {
/**
 * Compile a source code string into a runnable script.
 * @param {string} source - The source code string to compile.
 */
function compile(source) {
    // Remove existing script tag with id 'run-script' if exists
    var existingScriptTag = document.getElementById('run-script');
    if (existingScriptTag) {
        existingScriptTag.parentNode.removeChild(existingScriptTag);
    }
    
    // Fetch POST request with source code as JSON data
    fetch('http://localhost:8080', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({instruction: source})
    })
    .then(response => response.text()) // Get response text content
    .then(data => {
        // Create a new script tag with id 'run-script' and add response text content to it
        var newScriptTag = document.createElement('script');
        newScriptTag.id = 'run-script';
        newScriptTag.textContent = data;
        document.body.appendChild(newScriptTag);
    })
    .catch(error => console.error('Error:', error)); // Handle any errors that occurred during fetch request
}

function ide(win, path) {
    // Create root element
    const ideRoot = document.createElement('div');
    ideRoot.className = 'ide';
    
    // Create textarea element
    const textarea = document.createElement('textarea');
    textarea.style.width = '100%';
    textarea.style.height = '500px';
    
    // If path is not empty, read file content and set it to textarea
    if (path) {
        const content = window.os.fs.getFileContentFromPath(path);
        if (content) textarea.value = content;
    }
    
    // Create toolbar on win
    const addButton = window.os.gui.createToolbar(win);
    
    // Add buttons on toolbar
    addButton('▶️', () => compile(textarea.value)); // Execute compile on click
    addButton('💾', () => { // Save on click
        if (path) {
            window.os.fs.write(path, textarea.value);
        } else {
            path = prompt('Please enter a path');
            if (path) window.os.fs.write(path, textarea.value);
        }
    });
    
    // Append textarea to root element
    ideRoot.appendChild(textarea);
    
    // Return root element
    return ideRoot;
}

// Register application with 'IDE' title, 🧠 as emoji, ide function reference and 800x600 size
window.os.registerApplication('IDE', '🧠', ide, 800, 600, ['script']);


})()
  </script>
  <script id="games_minesweper">
   (() => {
function minesweeper() {
    // Create root element
    const root = document.createElement('div');
    root.className = 'gmroot';
    
    // Create matrix of size 8x8 with values 0
    const matrix = Array(8).fill().map(() => Array(8).fill(0));
    
    // Pick 10 random cells and set their value to -40 and increase the number value of the neighbouring cells
    let mines = [];
    for (let i = 0; i < 10; i++) {
        let x = Math.floor(Math.random() * 8);
        let y = Math.floor(Math.random() * 8);
        mines.push({x, y});
        matrix[x][y] = -40;
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                if (dx === 0 && dy === 0) continue;
                let nx = x + dx;
                let ny = y + dy;
                if (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) matrix[nx][ny]++;
            }
        }
    }
    
    // Set score to 64
    let score = 64;
    
    // Add score div
    const scoreDiv = document.createElement('div');
    scoreDiv.className = 'score';
    scoreDiv.textContent = `Discovered: ${score}`;
    root.appendChild(scoreDiv);
    
    // Add matrix rows
    for (let i = 0; i < 8; i++) {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'row';
        for (let j = 0; j < 8; j++) {
            const cellDiv = document.createElement('div');
            cellDiv.className = 'cell';
            cellDiv.textContent = ' ';
            cellDiv.dataset.x = i;
            cellDiv.dataset.y = j;
            cellDiv.addEventListener('click', () => reveal(i, j));
            rowDiv.appendChild(cellDiv);
        }
        root.appendChild(rowDiv);
    }
    
    // Define reveal function
    const reveal = (x, y) => {
        let cellDiv = document.querySelector(`div[data-x="${x}"][data-y="${y}"]`);
        if (cellDiv.classList.contains('visited')) return;
        let value = matrix[x][y];
        cellDiv.textContent = value < 0 ? '💣' : value;
        cellDiv.classList.add('visited');
        if (value < 0) {
            alert('Game Over');
            return;
        } else if (value === 0) {
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    let nx = x + dx;
                    let ny = y + dy;
                    if (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) reveal(nx, ny);
                }
            }
        }
        score--;
        scoreDiv.textContent = `Discovered: ${score}`;
    };
    
    return root;
};

window.os.registerApplication('Minesweeper', '💣', minesweeper, 300, 300);


})()
  </script>
 </body>
</html>
